{"version":3,"file":"client.gen-Crtm1jAh.js","sources":["../../../Client/src/api/core/bodySerializer.ts","../../../Client/src/api/core/auth.ts","../../../Client/src/api/core/pathSerializer.ts","../../../Client/src/api/client/utils.ts","../../../Client/src/api/client/client.ts","../../../Client/src/api/client.gen.ts"],"sourcesContent":["import type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (\n  data: FormData,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): FormData => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T): string =>\n    JSON.stringify(body, (_key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): string => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","export type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import { getAuthToken } from '../core/auth';\nimport type {\n  QuerySerializer,\n  QuerySerializerOptions,\n} from '../core/bodySerializer';\nimport { jsonBodySerializer } from '../core/bodySerializer';\nimport {\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '../core/pathSerializer';\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\ninterface PathSerializer {\n  path: Record<string, unknown>;\n  url: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style: ArraySeparatorStyle = 'simple';\n\n      if (name.endsWith('*')) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n\n      if (name.startsWith('.')) {\n        name = name.substring(1);\n        style = 'label';\n      } else if (name.startsWith(';')) {\n        name = name.substring(1);\n        style = 'matrix';\n      }\n\n      const value = path[name];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        url = url.replace(\n          match,\n          serializeArrayParam({ explode, name, style, value }),\n        );\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        url = url.replace(\n          match,\n          serializeObjectParam({\n            explode,\n            name,\n            style,\n            value: value as Record<string, unknown>,\n            valueOnly: true,\n          }),\n        );\n        continue;\n      }\n\n      if (style === 'matrix') {\n        url = url.replace(\n          match,\n          `;${serializePrimitiveParam({\n            name,\n            value: value as string,\n          })}`,\n        );\n        continue;\n      }\n\n      const replaceValue = encodeURIComponent(\n        style === 'label' ? `.${value as string}` : (value as string),\n      );\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n  allowReserved,\n  array,\n  object,\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    const search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam({\n            allowReserved,\n            explode: true,\n            name,\n            style: 'form',\n            value,\n            ...array,\n          });\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === 'object') {\n          const serializedObject = serializeObjectParam({\n            allowReserved,\n            explode: true,\n            name,\n            style: 'deepObject',\n            value: value as Record<string, unknown>,\n            ...object,\n          });\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value as string,\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n\n    return;\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) => {\n  const url = getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n  return url;\n};\n\nexport const getUrl = ({\n  baseUrl,\n  path,\n  query,\n  querySerializer,\n  url: _url,\n}: {\n  baseUrl?: string;\n  path?: Record<string, unknown>;\n  query?: Record<string, unknown>;\n  querySerializer: QuerySerializer;\n  url: string;\n}) => {\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\n  let url = (baseUrl ?? '') + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({ path, url });\n  }\n  let search = query ? querySerializer(query) : '';\n  if (search.startsWith('?')) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += `?${search}`;\n  }\n  return url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header || typeof header !== 'object') {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers ? header.entries() : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  _fns: (Interceptor | null)[];\n\n  constructor() {\n    this._fns = [];\n  }\n\n  clear() {\n    this._fns = [];\n  }\n\n  getInterceptorIndex(id: number | Interceptor): number {\n    if (typeof id === 'number') {\n      return this._fns[id] ? id : -1;\n    } else {\n      return this._fns.indexOf(id);\n    }\n  }\n  exists(id: number | Interceptor) {\n    const index = this.getInterceptorIndex(id);\n    return !!this._fns[index];\n  }\n\n  eject(id: number | Interceptor) {\n    const index = this.getInterceptorIndex(id);\n    if (this._fns[index]) {\n      this._fns[index] = null;\n    }\n  }\n\n  update(id: number | Interceptor, fn: Interceptor) {\n    const index = this.getInterceptorIndex(id);\n    if (this._fns[index]) {\n      this._fns[index] = fn;\n      return id;\n    } else {\n      return false;\n    }\n  }\n\n  use(fn: Interceptor) {\n    this._fns = [...this._fns, fn];\n    return this._fns.length - 1;\n  }\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Pick<\n    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;\n  response: Pick<\n    Interceptors<ResInterceptor<Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import type { Client, Config, RequestOptions } from './types';\nimport {\n  buildUrl,\n  createConfig,\n  createInterceptors,\n  getParseAs,\n  mergeConfigs,\n  mergeHeaders,\n  setAuthParams,\n} from './utils';\n\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\n  body?: any;\n  headers: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n  let _config = mergeConfigs(createConfig(), config);\n\n  const getConfig = (): Config => ({ ..._config });\n\n  const setConfig = (config: Config): Config => {\n    _config = mergeConfigs(_config, config);\n    return getConfig();\n  };\n\n  const interceptors = createInterceptors<\n    Request,\n    Response,\n    unknown,\n    RequestOptions\n  >();\n\n  const request: Client['request'] = async (options) => {\n    const opts = {\n      ..._config,\n      ...options,\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n      headers: mergeHeaders(_config.headers, options.headers),\n    };\n\n    if (opts.security) {\n      await setAuthParams({\n        ...opts,\n        security: opts.security,\n      });\n    }\n\n    if (opts.requestValidator) {\n      await opts.requestValidator(opts);\n    }\n\n    if (opts.body && opts.bodySerializer) {\n      opts.body = opts.bodySerializer(opts.body);\n    }\n\n    // remove Content-Type header if body is empty to avoid sending invalid requests\n    if (opts.body === undefined || opts.body === '') {\n      opts.headers.delete('Content-Type');\n    }\n\n    const url = buildUrl(opts);\n    const requestInit: ReqInit = {\n      redirect: 'follow',\n      ...opts,\n    };\n\n    let request = new Request(url, requestInit);\n\n    for (const fn of interceptors.request._fns) {\n      if (fn) {\n        request = await fn(request, opts);\n      }\n    }\n\n    // fetch must be assigned here, otherwise it would throw the error:\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n    const _fetch = opts.fetch!;\n    let response = await _fetch(request);\n\n    for (const fn of interceptors.response._fns) {\n      if (fn) {\n        response = await fn(response, request, opts);\n      }\n    }\n\n    const result = {\n      request,\n      response,\n    };\n\n    if (response.ok) {\n      if (\n        response.status === 204 ||\n        response.headers.get('Content-Length') === '0'\n      ) {\n        return opts.responseStyle === 'data'\n          ? {}\n          : {\n              data: {},\n              ...result,\n            };\n      }\n\n      const parseAs =\n        (opts.parseAs === 'auto'\n          ? getParseAs(response.headers.get('Content-Type'))\n          : opts.parseAs) ?? 'json';\n\n      let data: any;\n      switch (parseAs) {\n        case 'arrayBuffer':\n        case 'blob':\n        case 'formData':\n        case 'json':\n        case 'text':\n          data = await response[parseAs]();\n          break;\n        case 'stream':\n          return opts.responseStyle === 'data'\n            ? response.body\n            : {\n                data: response.body,\n                ...result,\n              };\n      }\n\n      if (parseAs === 'json') {\n        if (opts.responseValidator) {\n          await opts.responseValidator(data);\n        }\n\n        if (opts.responseTransformer) {\n          data = await opts.responseTransformer(data);\n        }\n      }\n\n      return opts.responseStyle === 'data'\n        ? data\n        : {\n            data,\n            ...result,\n          };\n    }\n\n    const textError = await response.text();\n    let jsonError: unknown;\n\n    try {\n      jsonError = JSON.parse(textError);\n    } catch {\n      // noop\n    }\n\n    const error = jsonError ?? textError;\n    let finalError = error;\n\n    for (const fn of interceptors.error._fns) {\n      if (fn) {\n        finalError = (await fn(error, response, request, opts)) as string;\n      }\n    }\n\n    finalError = finalError || ({} as string);\n\n    if (opts.throwOnError) {\n      throw finalError;\n    }\n\n    // TODO: we probably want to return error and improve types\n    return opts.responseStyle === 'data'\n      ? undefined\n      : {\n          error: finalError,\n          ...result,\n        };\n  };\n\n  return {\n    buildUrl,\n    connect: (options) => request({ ...options, method: 'CONNECT' }),\n    delete: (options) => request({ ...options, method: 'DELETE' }),\n    get: (options) => request({ ...options, method: 'GET' }),\n    getConfig,\n    head: (options) => request({ ...options, method: 'HEAD' }),\n    interceptors,\n    options: (options) => request({ ...options, method: 'OPTIONS' }),\n    patch: (options) => request({ ...options, method: 'PATCH' }),\n    post: (options) => request({ ...options, method: 'POST' }),\n    put: (options) => request({ ...options, method: 'PUT' }),\n    request,\n    setConfig,\n    trace: (options) => request({ ...options, method: 'TRACE' }),\n  };\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from './types.gen';\nimport { type Config, type ClientOptions as DefaultClientOptions, createClient, createConfig } from './client';\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(createConfig<ClientOptions>({\n    baseUrl: 'http://localhost:59927'\n}));"],"names":["jsonBodySerializer","body","_key","value","getAuthToken","auth","callback","token","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","valueOnly","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","url","matches","match","replaceValue","createQuerySerializer","array","object","queryParams","search","serializedArray","serializedObject","serializedPrimitive","getParseAs","contentType","_a","cleanContent","type","setAuthParams","security","options","buildUrl","getUrl","baseUrl","query","querySerializer","pathUrl","mergeConfigs","a","b","config","mergeHeaders","headers","mergedHeaders","header","iterator","Interceptors","id","index","fn","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","createClient","_config","getConfig","setConfig","interceptors","request","opts","requestInit","_fetch","response","result","parseAs","data","textError","jsonError","error","finalError","client"],"mappings":"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"}